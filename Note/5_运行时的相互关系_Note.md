<h2>4.4 运行时的相互关系</h2>



> 本节将解释**类型**、**对象**、**线程栈**和**托管堆**在运行时的相互关系。此外，还将解释调用静态方法、实例方法和虚方法的区别。首先从一些计算机基础知识开始。虽然下面讨论的东西不是CLR特有的，但掌握了这些之后，就有了一个良好的理论基础。接着，就可以将我们的讨论转向CLR特有的内容。

<img src="https://github.com/Chilldd/CLR_via_C_Sharp_Note/blob/main/IMG/4.1/f97d6ac874f84434bc22e8d3f9285173.png?raw=true =" width="700px" />

> 然后，M1调用M2方法，将局部变量name作为实参传递。这造成name局部变量中的地址被压入栈(参见图4-4)。M2方法内部使用参数变量s标识栈位置(注意，有的CPU架构用寄存器传递实参以提升性能，但这个区别对于当前的讨论来说并不重要)。另外，调用方法时还会将“**返回地址**”压入栈。被调用的方法在结束之后应**返回至该位置**(同样参见图4-4)。

<img src="https://github.com/Chilldd/CLR_via_C_Sharp_Note/blob/main/IMG/4.1/982ee69fd17a4a0f870635ceddf8459d.png?raw=true =" width="700px" />

> M2方法开始执行时，它的“序幕”代码在线程栈中为局部变量length和tally 分配内存，如图4-5所示。然后，M2方法内部的代码开始执行。最终，M2抵达它的return语句，造成CPU的指令指针被设置成栈中的返回地址，M2的栈帧"展开(unwind)”，恢复成图4-3的样子。之后，M1继续执行M2调用之后的代码，M1的栈帧将准确反映M1需要的状态。

<img src="https://github.com/Chilldd/CLR_via_C_Sharp_Note/blob/main/IMG/4.1/23812cf6b59a4abfac46d669e2cdf91f.png?raw=true =" width="700px" />

> 最终，M1会返回到它的调用者。这同样通过将CPU的指令指针设置成返回地址来实现(这个返回地址在图中未显示，但它应该刚好在栈中的name实参上方)，M1的栈帧展开(unwind)，恢复成图4-2的样子。之后，调用M1的方法继续执行M1调用之后的代码，那个方法的栈帧将准确反映它需要的状态。

> 1. 栈帧(stack frame)代表当前线程的调用栈中的一个方法调用。执行线程的过程中，进行的每个方法调用
>    都会在调用栈中创建并压入一个StackFrame。 一译注
> 2. unwind 一般翻译成“展开”，但这并不是一个很好的翻译。wind 和unwind源于生活。把线缠到线圈上称为wind;从线圈上松开称为unwind。同样地，调用方法时压入栈帧，称为wind; 方法执行完毕，弹出栈帧，称为unwind。把这几张图的线程栈看成一个线圈，就很容易理解了。一译注

