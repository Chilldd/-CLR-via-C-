<h2>5.2/5.3 引用/值类型</h2>



> CLR支持两种类型: 引用类型和值类型。
>
> 虽然FCL的大多数类型都是引用类型，但程序员用得最多的还是值类型。引用类型总是从**托管堆**分配，C#的new操作符返回对象内存地址一即**指向对象数据的内存地址**。使用引用类型必须留意性能问题。首先要认清楚以下四个事实：
>
> 1. 内存必须从托管堆分配。
> 2. 堆上分配的每个对象都有一些额外成员，这些成员必须初始化。
>
> 3. 对象中的其他字节(为字段而设)总是设为零。
> 4. 从托管堆分配对象时，可能强制执行一次垃圾回收。
>
> 如果所有类型都是引用类型，应用程序的性能将显著下降。设想每次使用Int32 值时都进
> 行一次内存分配，性能会受到多么大的影响!为了提升简单和常用的类型的性能，CLR提
> 供了名为“值类型”的轻量级类型。值类型的实例一般在线程栈上分配(虽然也可作为字段
> 嵌入引用类型的对象中)。在代表值类型实例的变量中不包含指向实例的指针。相反，变量
> 中包含了实例本身的字段。由于变量已包含了实例的字段，所以操作实例中的字段不需要
> 提领指针。值类型的实例不受垃圾回收器的控制。因此，值类型的使用缓解了托管堆的压
> 力，并减少了应用程序生存期内的垃圾回收次数。
>
> 文档清楚指出哪些类型是引用类型，哪些是值类型。在文档中查看类型时，任何称为“类”
> 的类型都是引用类型。例如，System.Exception 类、System.IO.FileStream 类以及
> System.Random类都是引用类型。相反，所有值类型都称为结构或枚举。例如，System.Int32
> 结构、System.Boolean结构、System.Decimal结构、System.TimeSpan结构、System.DayOfWeek
> 枚举、System.I0.filAtributes 枚举以及System.Drawing.FontStyle 枚举都是值类型。
>
> 进一步研究文档，会发现所有结构都是抽象类型System.ValueType的直接派生类。
> System.ValueType本身又直接从System.Object 派生。根据定义，所有值类型都必须从
> System.ValueType派生。所有枚举都从System.Enum 抽象类型派生，后者又从
> System.ValueType派生。CLR和所有编程语言都给予枚举特殊待遇”。欲知枚举类型的详
> 情，请参见第15章“枚举类型和位标志”
>
> 虽然不能在定义值类型时为它选择基类型，但如果愿意，值类型可实现一个或多个接口。
> 除此之外，所有值类型都隐式密封，目的是防止将值类型用作其他引用类型或值类型的基
> 类型。例如，无法将Boolean, Char，Int32， Ulnt64， Single， Double, Decimal 等作为基类型来定义任何新类型
>
> <img src="https://github.com/Chilldd/CLR_via_C_Sharp_Note/blob/main/IMG/5.2/642a8f3dd1904d3985eff66f930486a1.png?raw=true =" width="700px" />
>
> <img src="https://github.com/Chilldd/CLR_via_C_Sharp_Note/blob/main/IMG/5.2/0a07100986f4477191dad4e14d417fe8.png?raw=true =" width="700px" />
>
> 设计自己的类型时，要仔细考虑类型是否应该定义成值类型而不是引用类型。值类型有时
> 能提供更好的性能。具体地说，除非满足以下全部条件，否则不应将类型声明为值类型。
> 类型具有基元类型的行为。也就是说，是十分简单的类型，没有成员会修改类型的任
> 何实例字段。如果类型没有提供会更改其字段的成员,就说该类型是不可变(immutable)
> 类型。事实上，对于许多值类型，我们都建议将全部字段标记为readonly(详情参见第
> 7章“常量和字段”)。
> ●类型不需要从其他任何类型继承。
> ●类型也不派生出其他任何类型。
> 类型实例大小也应在考虑之列，因为实参默认以传值方式传递，造成对值类型实例中的字
> 段进行复制，对性能造成损害。同样地，被定义为返回一个值类型的方法在返回时，实例
> 中的字段会复制到调用者分配的内存中，对性能造成损害。所以，要将类型声明为值类型，
> 除了要满足以上全部条件，还必须满足以下任意条件。
>
> 类型的实例较小(16字节或更小)。
> 类型的实例较大(大于16字节)，但不作为方法实参传递，也不从方法返回。
> 值类型的主要优势是不作为对象在托管堆上分配。当然，与引用类型相比，值类型也存在
> 自身的一-些局限。下面列出了值类型和引用类型的一-些区别。
> 值类型对象有两种表示形式:未装箱和已装箱，详情参见下一-节。相反，引用类型总
> 是处于已装箱形式。
> ●值类型从 System.ValueType 派生。该类型提供了与System.Object 相同的方法。但
> System.ValueType重写了Equals 方法，能在两个对象的字段值完全匹配的前提下返
> 回true。此外，System.ValueType 重写了GetHashCode 方法。生成哈希码时，这个
> 重写方法所用的算法会将对象的实例字段中的值考虑在内。由于这个默认实现存在性
> 能问题，所以定义自己的值类型时应写Equals和GetHashCode方法，并提供它们
> 的显式实现。本章末尾会讨论Equals和GetHashCode方法。
> ●由于不能将值类型作为基类型来定义新的值类型或者新的引用类型，所以不应在值类
> 型中引入任何新的虚方法。所有方法都不能是抽象的，所有方法都隐式密封(不可
> 重写)。
> 引用类型的变量包含堆中对象的地址。引用类型的变量创建时默认初始化为null，表
> 明当前不指向有效对象。试图使用null引用类型变量会抛出NullReferenceException
> 异常。相反，值类型的变量总是包含其基础类型的一个值，而且值类型的所有成员都
> 初始化为0。值类型变量不是指针，访问值类型不可能抛出NullReferenceException
> 异常。CLR确实允许为值类型添加“可空”(nullability)标识。可空类型将在第19章“可
> 空值类型”详细讨论。
> ●将值类型变量赋给另一个值类型变量，会执行逐字段的复制。将引用类型的变量赋给
> 另一个引用类型的变量只复制内存地址。
> 基于上一条，两个或多个引用类型变量能引用堆中同一个对象，所以对一个变量执行
> 的操作可能影响到另一个变量引用的对象。相反，值类型变量自成一-体，对值类型变量执行的操作不可能影响另-一个值类型变量。
> 由于未装箱的值类型不在堆上分配，-旦定义了该类型的一一个实例的方法不再活动，
> 为它们分配的存储就会被释放，而不是等着进行垃圾回收。
>
> <img src="https://github.com/Chilldd/CLR_via_C_Sharp_Note/blob/main/IMG/5.2/dd0faac110c04c5b99d60c1fc0bd11e6.png?raw=true =" width="700px" />
>
> 摘自《CLR via C# 》第一百零六页至一百一十页

