<h2>4.1/4.2 Object</h2>

<h3>new 操作符</h3>

>CLR要求所有对象都用new操作符创建。以下代码展示了如何创建一个Employee对象：
>
>Employee e = new Employee ("ConstructorParaml") ;
>
>以下是new操作符所做的事情。
>
>1. 计算类型及其所有基类型(一直到System.Object， 虽然它没有定义自己的实例字段)中
>     定义的**所有实例字段(此处实例字段指非静态字段)需要的字节数**。堆上每个对象都需要一些**额外的成员**，包括**“类**
>     **型对象指针”(type object pointer)和“同步块索引”(sync block index)**。CLR 利用这些
>     成员管理对象。**额外成员的字节数要计入对象大小**。
>
>   > **实例成员属于类的对象(实例化之后的类)，静态成员属于类**
>
>2. **从托管堆中分配类型要求的字节数，从而分配对象的内存，分配的所有字节都设为零(0)**。
>
>3. **初始化对象的 “类型对象指针”和“同步块索引”成员**。
>
>   > 类型对象指针、同步块索引后面会专门写一篇介绍
>
>4. 调用类型的**实例构造器(构造函数)**， 传递在new调用中指定的实参(上例就是字符串"ConstructorParam1")。大多数编译器都在构造器中**自动生成代码来调用基类构造器**。每个类型的构造器都负责初始化**该类型定义的实例字段**。最终调用System.Object 的构造器，该构造器什么都不做，简单地返回。
>
>new执行了所有这些操作之后,返回指向新建对象一个**引用(或指针)**。在前面的示例代码中，该引用保存到变量e中，后者具有Employee类型。顺便说一-句，没有和new操作符对应的delete操作符。换言之，**没有办法显式释放为对象分配的内存**。CLR采用了垃圾回收机制(详情在第21章讲述)，能自动检测到一个对象不再被使用或访问，并自动释放对象的内存。
>
>摘自《CLR via C# 》第八一页至八十三页



<h3>类型转换</h3>

> CLR最重要的特性之一就是**类型安全**。在运行时，CLR总是知道对象的类型是什么。调用GetType方法即可知道对象的确切类型。由于它是**非虚方法**，所以一个类型**不可能伪装**成另一个类型。例如，Employee 类型不能重写GetType方法并返回一个SuperHero类型。
>
> 开发人员经常需要将对象从一种类型转换为另种类型。CLR允许将对象转换为它的(实际)类型或者它的任何基类型。每种编程语言都规定了开发人员具体如何进行这种转型操作。
> 例如，C#不要求任何特殊语法即可将对象转换为它的任何基类型，因为**向基类型的转换**被认为是一种**安全的隐式转换**。然而，将对象转**换为它的某个派生类**型时，C#要求开发人员**只能进行显式转换**，因为这种转换可能在**运行时失败**。
>
> 摘自《CLR via C# 》第八三页至八十五页

