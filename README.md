# 《CLR via C#》学习笔记

<h2>目录</h2>

| **标题**                             | **页码  ** | **笔记**                                                     | **重要等级** |
| ------------------------------------ | ---------- | ------------------------------------------------------------ | ------------ |
| 1.4  执行程序集的代码                | 10         | 1. IL是什么<br/>**2. IL如何转化为CPU指令****<br/>3. 方法被调用时，发生过程** | **高**       |
| 1.7  通用类型系统（CTS）             | 22         | CTS(Common Type System)介绍                                  | 中           |
| 1.8  公共语言规范                    | 24         | CLS(Common Language Specification)公共语言规范               | 中           |
| 4.1  所有对象都从Object派生          | 81         | 1. Object介绍<br/>**2. new操作符所做的事情**                 | **高**       |
| 4.2  类型转换                        | 83         | 对象如何进行安全的类型转换                                   | **高**       |
| 4.4  运行时的相互关系                | 90         | **1. 类型，对象，线程栈，托管堆在运行时的相互关系****<br/>2. 静态方法，实例方法，虚方法的调用区别** | **高**       |
| 5.1  基元类型                        | 99         | **基元类型介绍**                                             | **高**       |
| 5.2  引用类型，值类型                | 106        | **值类型和引用类型的区别**                                   | **高**       |
| 5.3  装箱，拆箱                      | 111        | **装箱和拆箱详解**                                           | **高**       |
| 6.4  静态类                          | 141        | **静态类**                                                   | 中           |
| 6.6.1  CLR如何调用虚方法、属性和事件 | 145        | **CLR如何调用方法**                                          | **高**       |
| 7  常量和字段                        | 155        | **1. 常量****<br/>2. 字段****<br/>3. readonly(readonly修饰引用类型时，不可变的是引用，而不是引用的对象)** | **高**       |
| 8  方法                              | 161        | **1. 构造函数（值类型，引用类型）****<br/>2. 类型构造器****<br/>3. 操作符方法****<br/>4. 扩展方法****<br/>5. 分部方法** | **高**       |





<h2>CLR基础</h2>



> 公共语言运行时(Common Language Runtime, CLR)是一个可由**多种编程语言使用**的“运行时”。CLR的核心功能(比如内存管理、程序集加载、安全性、异常处理和线程同步)可**由面向CLR的所有语言使用**。例如，“运行时” 使用异常来报告错误: 因此，面向它的任何语言都能通过异常来报告错误。另外，“运行时”允许创建线程，所以面向它的任何语言都能创建线程。
>
> 摘自《CLR via C# 》第四页



> .NET 提供了一个称为公共语言运行时的运行时环境，它运行代码并提供使开发过程更轻松的服务。
>
> 公共语言运行时的功能通过编译器和工具公开，你可以编写利用此托管执行环境的代码。 使用**面向运行时的语言编译器开发的代码称为托管代码**。 托管代码具有许多优点，例如：**跨语言集成、跨语言异常处理、增强的安全性、版本控制和部署支持、简化的组件交互模型、调试和分析服务**等。
>
> 若要使公共语言运行时能够向托管代码提供服务，语言编译器必须生成一些**元数据**来描述代码中的类型、成员和引用。 **元数据与代码一起存储**；每个可加载的公共语言运行时可迁移执行 (PE) 文件都包含元数据。 公共语言运行时使用元数据来完成以下任务：**查找和加载类，在内存中安排实例，解析方法调用，生成本机代码，强制安全性，以及设置运行时上下文边界**。
>
> 公共语言运行时自动处理对象布局并管理对象引用，当不再使用对象时释放它们。 **按这种方式实现生存期管理的对象称为托管数据**。 垃圾回收消除了内存泄漏以及其他一些常见的编程错误。 如果你编写的代码是托管代码，则可以在 .NET 应用程序中使用托管数据、非托管数据或者同时使用这两种数据。 由于语言编译器会提供自己的类型（如基元类型），因此你可能并不总是知道（或需要知道）这些数据是否是托管的。
>
> 有了公共语言运行时，就可以很容易地设计出对象能够跨语言交互的组件和应用程序。 也就是说，用不同语言编写的对象可以互相通信，并且它们的行为可以紧密集成。 例如，可以定义一个类，然后使用不同的语言从原始类派生出另一个类或调用原始类的方法。 还可以将一个类的实例传递到用不同的语言编写的另一个类的方法。 这种跨语言集成之所以成为可能，是因为基于公共语言运行时的语言编译器和工具使用由公共语言运行时定义的常规类型系统，而且它们遵循公共语言运行时关于定义新类型以及创建、使用、保持和绑定到类型的规则。
>
> 所有托管组件都带有生成它们所基于的组件和资源的信息，这些信息构成了元数据的一部分。 公共语言运行时使用这些信息确保组件或应用程序具有它需要的所有内容的指定版本，这样就使代码不太可能由于某些未满足的依赖项而发生中断。 注册信息和状态数据不再保存在注册表中（因为在注册表中建立和维护这些信息很困难）。 取而代之的是，有关你定义的类型（及其依赖项）的信息作为元数据与代码存储在一起，这样大大降低了组件复制和移除任务的复杂性。
>
> 语言编译器和工具公开公共语言运行时的功能的方式对于开发人员来说不仅很有用，而且很直观。 这意味着，公共语言运行时的某些功能可能在一个环境中比在另一个环境中更突出。 你对公共语言运行时的体验取决于所使用的语言编译器或工具。 例如，如果你是一位 Visual Basic 开发人员，你可能会注意到：有了公共语言运行时，Visual Basic 语言的面向对象的功能比以前多了。 运行时提供如下优点：
>
> - 性能得到了改进。
> - 能够轻松使用用其他语言开发的组件。
> - 类库提供的可扩展类型。
> - 语言功能，如面向对象的编程的继承、接口和重载。
> - 允许创建多线程的可缩放应用程序的显式自由线程处理支持。
> - 结构化异常处理支持。
> - 自定义特性支持。
> - 垃圾回收。
> - 使用委托取代函数指针，从而增强了类型安全和安全性。 有关委派的详细信息，请参阅[通用类型系统](https://docs.microsoft.com/zh-cn/dotnet/standard/base-types/common-type-system)。
>
> 
>
> <a href="https://docs.microsoft.com/zh-cn/dotnet/standard/clr">摘自《微软官方文档/.Net 基础知识/执行模型/公共语言运行时(CLR)》</a>



